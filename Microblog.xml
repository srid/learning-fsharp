<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title type="text">Microblog - Learning F#</title><id>https://srid.github.io/learning-fsharp/Microblog</id><updated>2021-03-23</updated><link href="https://srid.github.io/learning-fsharp/Microblog"/><entry><id>https://srid.github.io/learning-fsharp/fsharp-wasm-static-demo</id><title type="text">SPA demo on Wasm</title><updated>2021-03-23</updated><content type="html">&lt;p&gt;A &lt;span class=&#34;zettel-link-container folgeinv&#34;&gt;&lt;span class=&#34;zettel-link&#34;&gt;&lt;span data-nosnippet=&#34;&#34; style=&#34;user-select: none; color: gray&#34; title=&#34;Folgezettel&#34;&gt;#&lt;/span&gt;&lt;a href=&#34;Bolero&#34;&gt;Bolero&lt;/a&gt;&lt;/span&gt;&lt;/span&gt; app demonstrating fully client-side app running in Wasm, but written entirely in F#. It is deployed to GitHub Pages, and there is no backend involved.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Source: &lt;a href=&#34;https://github.com/srid/fsharp-wasm-static-demo&#34;&gt;https://github.com/srid/fsharp-wasm-static-demo&lt;/a&gt;&lt;/li&gt;&lt;li&gt;Demo: &lt;a href=&#34;https://srid.github.io/fsharp-wasm-static-demo/&#34;&gt;https://srid.github.io/fsharp-wasm-static-demo/&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;code class=&#34;inline-tag&#34;&gt;#series&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;</content><link href="https://srid.github.io/learning-fsharp/fsharp-wasm-static-demo"/></entry><entry><id>https://srid.github.io/learning-fsharp/01-first-program</id><title type="text">First Program</title><updated>2021-03-21</updated><content type="html">&lt;p&gt;I came across&lt;span data-nosnippet=&#34;&#34;&gt;&lt;sup class=&#34;footnote-ref&#34;&gt;&lt;a href=&#34;#fn1&#34; id=&#34;fnref1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/span&gt; the &lt;span class=&#34;zettel-link-container cf&#34;&gt;&lt;span class=&#34;zettel-link&#34;&gt;&lt;a href=&#34;Memstate&#34;&gt;Memstate&lt;/a&gt;&lt;/span&gt;&lt;/span&gt; library (after reading about CQRS and eventsourcedb), which seemed very similar to &lt;code&gt;acid-state&lt;/code&gt; on Haskell world, but based on CQRS and in the dotnet world. This would be a perfect candidate for a single-user full-stack web app project, and as a replacement of LiteDB.&lt;/p&gt;&lt;p&gt;There were &lt;em&gt;no&lt;/em&gt; examples for it in F#, however. So I bootstrapped a new dotnet console project and decided to get something working by referencing memstate’s tests.&lt;/p&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/srid/OneBird/blob/083cab366db6d1c5a3f8b1b595576d6f65772940/Program.fs&#34;&gt;Program.fs&lt;/a&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class=&#34;fsharp language-fsharp&#34;&gt;// Learn more about F# at http://docs.microsoft.com/dotnet/fsharp

open System
open Memstate
open Memstate.JsonNet

type Tweet =
    { Id: int
      Message: string
    }

type TwitterModel() =
    let mutable tweets: Tweet list = []

    member this.Tweets = tweets

    member this.PostTweet(msg: string) = 
        let tweet = { Tweet.Id = 1; Message = msg }
        tweets &amp;lt;- tweets @ [tweet]
        tweet
        

// Events 

type Tweeted(tweet: Tweet) =
    inherit Event()

// Commands

type PostTweet(msg: string) = 
    inherit Command&amp;lt;TwitterModel, int&amp;gt;()

    member this.Msg: string = msg
    
    override Command.Execute(model: TwitterModel): int =
        let tweet = model.PostTweet msg
        Command.RaiseEvent (new Tweeted(tweet))
        tweet.Id

// Query

type AllTweets() =
    inherit Query&amp;lt;TwitterModel, Tweet list&amp;gt;()

    override Query.Execute(model: TwitterModel) =
        model.Tweets

[&amp;lt;EntryPoint&amp;gt;]
let main argv =
    // TODO: understand concepts used
    printfn &amp;quot;Begin&amp;quot;
    async {
        let! engine = Engine.Start&amp;lt;TwitterModel&amp;gt;() |&amp;gt; Async.AwaitTask
        let cmd = new PostTweet(&amp;quot;Hello world&amp;quot;)
        let! res = engine.Execute(cmd) |&amp;gt; Async.AwaitTask
        printfn &amp;quot;res: %d&amp;quot; res
        let query = new AllTweets()
        let! allTweets = engine.Execute(query) |&amp;gt; Async.AwaitTask
        printfn &amp;quot;%A&amp;quot; allTweets
        printfn &amp;quot;Fin.&amp;quot;
    } |&amp;gt; Async.RunSynchronously
    0 // return an integer exit code&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Keep in mind that this is the first F# code I wrote, and I did that without actually formally studying the language ahead. There is a TODO in there as a reminder for myself to study the concurrency topic (the async stuff). Microsoft has pretty good &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/fsharp/tutorials/asynchronous-and-concurrent-programming/async?source=docs&#34;&gt;introductory docs&lt;/a&gt; on it.&lt;/p&gt;&lt;script src=&#34;https://utteranc.es/client.js&#34;
        repo=&#34;srid/learning-fsharp&#34;
        issue-term=&#34;pathname&#34;
        theme=&#34;github-light&#34;
        crossorigin=&#34;anonymous&#34;
        async&gt;
&lt;/script&gt;
&lt;h2 id=&#34;links&#34;&gt;Links&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;https://www.reddit.com/r/fsharp/comments/mablsh/memstate_inmemory_eventsourced_acidtransactional/&#34;&gt;r/fsharp post&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div id=&#34;footnotes&#34;&gt;&lt;ol&gt;&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://opensourcelibs.com/libs/eventstore&#34;&gt;https://opensourcelibs.com/libs/eventstore&lt;/a&gt;&lt;/p&gt;&lt;a href=&#34;#fnref1&#34;&gt;↩︎&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content><link href="https://srid.github.io/learning-fsharp/01-first-program"/></entry></feed>